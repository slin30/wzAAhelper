% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flatten_nested_df.R
\name{flatten_nested_df}
\alias{flatten_nested_df}
\title{Flatten a data.frame with one or more nested data.frame columns}
\usage{
flatten_nested_df(df)
}
\arguments{
\item{df}{A data.frame or data.table.}
}
\value{
If no nested columns are detected, the input is returned as-is.

If nested columns are detected, a \code{data.table} with all nested
columns unnested.
}
\description{
Custom unnesting function that tries to preserve name uniqueness
}
\details{
This is an alternative to \code{\link[tidyr]{unnest}}, although
it is not meant to be a strict replacement. The key difference is that the original
input is returned as a single, flattened table (meaning any rows that must be repeated, are).
Furthermore, the field name of the (each) nested column is appended to the (each) flattened
field-set, to make it easier to distinguish between (and trace) parent-child relationships
by name.

Finally, this function does not care about \code{NULL} element-containing nested lists, as it
uses indexing to extract nested rows on a per-row, per-column basis.
}
\note{
A common use-case is for Adobe Analytics Classification tables that contain child
relationships, which are returned as nested \code{data.frame}s.
}
\examples{
# First nested column
V2 <- list(
  data.frame(col1 = 1:5),
  data.frame(col1 = 2:3)
)
V2[3:10] <- list(NULL)

# Second nested column
V3 <- list()
V3[1:2] <- list(NULL)
V3[[3]] <- data.frame(key2 = letters[1:5], stringsAsFactors = FALSE)
V3[4:8] <- list(NULL)
V3[[9]] <- data.frame(key1 = letters[1:2], stringsAsFactors = FALSE)
V3[10]  <- list(NULL)

# Try it
flatten_nested_df(
  data.frame(
    V1 = LETTERS[1:10],
    V2 = cbind(V2),
    V3 = cbind(V3),
    V4 = letters[11:20]
  )
)
}
