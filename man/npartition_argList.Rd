% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/npartition_argList.R
\name{npartition_argList}
\alias{npartition_argList}
\title{Partition a single top arg into n chunks}
\usage{
npartition_argList(baseList, n = NULL, len = NULL, chunkLimit = NULL)
}
\arguments{
\item{baseList}{named list of args. Must be unnested, i.e. single-level}

\item{n}{integer of length 1. Number of partitions to make. \code{numeric} will be coerced via \code{as.integer}}

\item{len}{integer of length 1. Length of each partition. Will override \emph{n} if both are provided.}

\item{chunkLimit}{optional. Should almost never be used. Controls the upper limit of chunk size for
\link[wzMisc]{make_chunks}. Pre-set to 50K and should be left as-is.}
}
\value{
A nested list of length equal to \code{(baseList[["top"]]/n) + (baseList[["top"]] \%\% n)}.
If not present, an argument of "start" will be appended to enable data fetching indexing.

If \code{length(baseList[["top"]]) > 1} is \code{TRUE}, the resulting chunks will preserve
values beyond the first. The "start" argument for each chunk will always be of length 1, as the
API will only apply "start" to the first element of "top."

It is helpful to use the outputs in conjunction with the \code{enqueueOnly=TRUE} argument most
\code{\link[RSiteCatalyst]{RSiteCatalyst}} call constructors support, not only for
performance, but also general organization.
}
\description{
Take a base argument list with a "top" arg and partition into n chunks
}
\details{
There are three distinct uses for this function; the first two are the most important:
\itemize{
\item You have more than \code{50000} results and need to break your calls up to pull all available results.
Most often, this scenario is detected when you have a query return 50000 records, which is almost always
indicative of hitting the default 50K limit.
\item You have nested elements, e.g. you wish to break down \emph{n} products by \emph{p} types,
where you anticipate that the resulting \code{n x p} result is likely to exceed 50K. If you are (also) running a
time-series report, this is even more problematic.
\item You are pulling tens of thousands of data points, but expect that you will be under the 50K limit by
a safe margin. It is often inefficient to request (tens of) thousands of records in a single call, and
here, this function can be useful to simply reduce wait time.
}
}
\note{
This function calls \code{\link{expand_argList}}, so please refer to the documentation there for additional
caveats around using the returned results. If you wish to concomitantly use this function with \code{expand_arglist},
do so with a call to \code{lapply} or \code{Map} or \link[purrr]{map}.

Alternatively, an explicit \code{for} loop is useful as a means to handle the highest (outermost)
level of nesting, as this is usually clearer than creating nested lists of depth >= 3.
}
\examples{
#define a baselist
my_baseList <- list(
reportsuite.id = "myID",
date.from = "2016-09-01",
date.to = "2016-09-02",
elements = "my_element",
metrics = c("pageviews", "visits"),
segment.id = c("segment1", "segment2"),
date.granularity = "month",
top = 100000) #exceeds 50K limit!

npartition_argList(my_baseList, n = 2)
npartition_argList(my_baseList, n = 3) #not very efficient, see:
unlist(Map("[", npartition_argList(my_baseList, n = 3), "top"))
npartition_argList(my_baseList, n = 4)

#with top values >1L
my_baseList_2 <- list(
reportsuite.id = "myID",
date.from = "2016-09-01",
date.to = "2016-09-02",
elements = c("my_element_1", "my_element_2"),
metrics = c("pageviews", "visits"),
segment.id = c("segment1", "segment2"),
date.granularity = "month",
top = c(100000, 10))

npartition_argList(my_baseList_2, n = 2)

#With len
npartition_argList(my_baseList, len = 25000) # 4 chunks
npartition_argList(my_baseList, len = 1E6) # failback to chunkLimit of 5E4 len

#Error if length top != length elements, if length top > 1 OR length elements > 1
\dontrun{

# length 2 top, length 1 elements
bad_list_1 <- list(
reportsuite.id = "myID",
date.from = "2016-09-01",
date.to = "2016-09-02",
elements = c("my_element_1"),
metrics = c("pageviews", "visits"),
date.granularity = "month",
top = c(100000, 10))

npartition_argList(bad_list_1, n = 2)

# length 1 top, length 2 elements
bad_list_2 <- list(
reportsuite.id = "myID",
date.from = "2016-09-01",
date.to = "2016-09-02",
elements = c("my_element_1", "my_element_2"),
metrics = c("pageviews", "visits"),
date.granularity = "month",
top = c(100000))

npartition_argList(bad_list_2, n = 2)
}
}
