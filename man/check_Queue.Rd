% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/check_Queue.R
\name{check_Queue}
\alias{check_Queue}
\title{Check current queue with messaging}
\usage{
check_Queue(x = NULL, base = 2, max_wait = NULL, n = 1L,
  out = data.frame())
}
\arguments{
\item{x}{(optional) integer vector of report IDs to check. If not provided, will use the starting
set found via \code{GetQueue}.}

\item{base}{(optional) numeric vector of length 1. The base to use to (exponentially) increment
wait times between iterations. Defaults to \code{2}}

\item{max_wait}{(optional) numeric vector of length 1. The max interval, in seconds, to wait between
iterations.}

\item{n}{Internal iteration counter used for recursion.}

\item{out}{Internal result accumulator}
}
\value{
If > 1 iteration, a numeric vector equal in length to the number of starting queued reports,
where each element is a report ID, in order of processing, else \code{NULL}
}
\description{
Automatically check the current queue at pre-determined time intervals
}
\note{
This does not properly capture all completed reports, since there is a time delay between
the start of one and end of another iteration, and any reports that complete in that
interval will not be captured. This will be addressed shortly.

For future improvements, it is likely this will move from a strict expotential growth delay
to an averaged time delta model of sorts, perhaps with lookup on the queue time projected by
the server versus actual times.

At the moment, this is most useful for interactive sessions to denote when a set of queued reports
is complete.
}
\examples{
\dontrun{
check_Queue()
check_Queue(base = 1.5) # for shorter time intervals between iterations
check_Queue(max_wait = 60) # cap interval time at 1 minute, regardless of iteration count
}
}
